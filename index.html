<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minispill | 1980s Retro</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Grunnleggende kropp og bakgrunn for 1980s terminalfølelse */
        body {
            font-family: 'monospace', sans-serif; /* Retro terminal-font */
            background-color: #000000; /* Dyp svart bakgrunn */
            color: #00FFFF; /* Neon cyan/blå for all tekst */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1.5rem;
            box-sizing: border-box;
            /* Subtil retro-effekt (simulerer scanlines/støy) */
            background-image: linear-gradient(rgba(0, 255, 255, 0.05) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(0, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 3px 3px;
        }

        /* Hovedcontainer for alle elementer (stablingskontekst) */
        .main-wrapper {
            width: 100%;
            max-width: 900px; /* Maks bredde for lesbarhet */
            display: flex;
            flex-direction: column;
            gap: 2rem; /* Mellomrom mellom boksene */
        }

        /* Felles stil for alle de store, rektangulære boksene */
        .retro-box {
            background-color: #000000; /* Svart bakgrunn for boksene */
            border: 2px solid #00FFFF; /* Neon cyan kant */
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5), inset 0 0 5px rgba(0, 255, 255, 0.3); /* Neon glød */
            padding: 1.5rem;
            text-align: center;
        }

        /* Topp-boks: Tittel og menyknapper */
        .top-box {
            composes: retro-box; /* Arver fra retro-box */
            padding-top: 2rem;
            padding-bottom: 2rem;
        }

        h1 {
            font-size: 3rem; /* Stor og dominerende tittel */
            font-weight: bold;
            color: #00FFFF; /* Neon cyan */
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.8), 0 0 15px rgba(0, 255, 255, 0.6); /* Kraftig neon glød */
            margin-bottom: 2rem;
            letter-spacing: 0.1em; /* Mellomrom mellom bokstaver for retro-følelse */
        }

        .game-menu-retro {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1.5rem;
        }

        /* Stil for menyknappene */
        .retro-button {
            background-color: transparent;
            border: 2px solid #00FFFF; /* Neon cyan kant */
            color: #00FFFF; /* Neon cyan tekst */
            padding: 0.75rem 1.5rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.3); /* Subtil glød */
            border-radius: 0; /* Skarpe kanter */
        }

        .retro-button:hover {
            background-color: #00FFFF; /* Fyll med farge ved hover */
            color: #000000; /* Svart tekst ved hover */
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.8), 0 0 20px rgba(0, 255, 255, 0.6); /* Mer intens glød */
        }
        .retro-button:active {
            background-color: #00BBBB; /* Litt mørkere cyan ved klikk */
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.8);
        }
        .retro-button:disabled {
            border-color: #4B5563;
            color: #6B7280;
            cursor: not-allowed;
            opacity: 0.6;
            background-color: transparent;
            box-shadow: none;
        }
        .retro-button:disabled:hover {
            background-color: transparent;
            color: #6B7280;
            box-shadow: none;
        }


        /* Midtre boks: Spillområde */
        .game-area-retro {
            composes: retro-box; /* Arver fra retro-box */
            min-height: 350px; /* Minimum høyde */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .game-area-retro p {
            color: #00FFFF;
            font-size: 1.5rem;
            letter-spacing: 0.03em;
        }

        /* Spillspesifikke stiler inni spillområdet (justert til neon-tema) */
        #guessTheNumberGame, #questionGame, #snakeGame, #pongGame {
            background-color: #000000; /* Svart bakgrunn for spilldivs */
            border: none; /* Fjern intern ramme om nødvendig */
            box-shadow: none; /* Fjern intern skygge om nødvendig */
            padding: 0; /* Fjern padding om nødvendig for renere look */
            width: 100%; /* Sørg for at den fyller game-area-retro */
            max-width: none;
        }

        #guessTheNumberGame h2, #questionGame h2, #snakeGame h2, #pongGame h2 {
            color: #00FFFF; /* Neon cyan */
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.8);
            margin-bottom: 1rem;
            font-size: 2rem;
        }

        #guessTheNumberGame input[type="number"],
        #questionGame input[type="text"],
        #userChatInput,
        #loginEmail, #loginPassword, #registerEmail, #registerPassword, #registerNickname { /* Added login/register inputs */
            background-color: #000000;
            border: 1px solid #00FFFF;
            color: #00FFFF;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
            padding: 0.6rem 1rem;
            border-radius: 0;
            text-align: center;
            font-size: 1.125rem;
            letter-spacing: 0.03em;
        }
        #guessTheNumberGame input[type="number"]:focus,
        #questionGame input[type="text"]:focus,
        #userChatInput:focus,
        #loginEmail:focus, #loginPassword:focus, #registerEmail:focus, #registerPassword:focus, #registerNickname:focus { /* Added login/register inputs focus */
            outline: none;
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.8), inset 0 0 3px rgba(0, 255, 255, 0.5);
        }

        /* Knapper inne i spill- og chat-områdene */
        #guessTheNumberGame button,
        #questionGame button,
        #snakeGameControls button,
        #pongGameControls button,
        #userChatContainer button:not(#userChatSendButton), /* Spesifikk for "Tøm Chat", "Logg ut" */
        #loginForm button, #registerForm button { /* Added login/register buttons */
            background-color: transparent;
            border: 2px solid #00FFFF;
            color: #00FFFF;
            padding: 0.6rem 1.2rem;
            font-weight: bold;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
            border-radius: 0;
            transition: background-color 0.2s, color 0.2s, box-shadow 0.2s;
            margin-top: 1rem; /* Mer avstånd fra input */
        }

        #guessTheNumberGame button:hover,
        #questionGame button:hover,
        #snakeGameControls button:hover,
        #pongGameControls button:hover,
        #userChatContainer button:not(#userChatSendButton):hover,
        #loginForm button:hover, #registerForm button:hover { /* Added login/register buttons hover */
            background-color: #00FFFF;
            color: #000000;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.8), 0 0 20px rgba(0, 255, 255, 0.6);
        }
        #guessTheNumberGame button:active,
        #questionGame button:active,
        #snakeGameControls button:active,
        #pongGameControls button:active,
        #userChatContainer button:not(#userChatSendButton):active,
        #loginForm button:active, #registerForm button:active { /* Added login/register buttons active */
            background-color: #00BBBB;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.8);
        }

        /* Snake og Pong Canvas */
        #snakeCanvas, #pongCanvas {
            background-color: #0A0A0A; /* Nesten svart for spillområdet */
            border: 2px solid #00FFFF;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6), inset 0 0 5px rgba(0, 255, 255, 0.3);
            border-radius: 0;
            width: 100%; /* For responsive canvas */
            height: auto; /* Maintain aspect ratio */
            max-width: 400px; /* Maks bredde som i forrige versjon */
            aspect-ratio: 1 / 1; /* Behold kvadratisk for snake */
        }
        #pongCanvas {
            max-width: 500px; /* Maks bredde for pong */
            aspect-ratio: 5 / 3; /* Pong aspect ratio */
        }
        
        /* Justering av elementer i Snake/Pong for å passe temaet */
        /* Snake */
        #snakeCanvas + #snakeGameControls button { margin-top: 1.5rem; }
        #snakeScore { color: #00FFFF; text-shadow: 0 0 5px rgba(0, 255, 255, 0.5); }

        /* Pong */
        #pongCanvas + #pongGameControls button { margin-top: 1.5rem; }
        #pongScore { color: #00FFFF; text-shadow: 0 0 5px rgba(0, 255, 255, 0.5); }
        #pongMessage { color: #FFFF00; text-shadow: 0 0 5px rgba(255, 255, 0, 0.5); }
        .pong-controls-info { color: #00FFFF; font-size: 0.85rem; }


        /* Bunn-boks: Bruker Chat */
        .bottom-box {
            composes: retro-box; /* Arver fra retro-box */
        }

        #userChatOutput {
            background-color: #0A0A0A; /* Mørkere bakgrunn for chat-output */
            border: 1px solid #00FFFF;
            color: #00FFFF;
            padding: 1rem;
            min-height: 150px; /* Mindre chat-vindu som i bildet */
            max-height: 250px; /* Liten, men scrollbar hvis mer innhold */
            overflow-y: auto;
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            line-height: 1.4;
            border-radius: 0;
            box-shadow: inset 0 0 5px rgba(0, 255, 255, 0.3);
        }

        .chat-message {
            padding: 0.3rem 0.6rem;
            border-radius: 0; /* Skarpe kanter */
            max-width: 95%; /* Mindre marger */
            word-break: break-word; /* Sikrer at lange ord brytes */
        }

        .user-chat-message {
            background-color: rgba(0, 150, 255, 0.2); /* Semi-transparent blå */
            border-left: 3px solid #00FFFF; /* Marker venstre side */
            align-self: flex-start;
        }
        .current-user-chat-message {
            background-color: rgba(0, 255, 0, 0.1); /* Semi-transparent grønn for egen melding */
            border-right: 3px solid #00FFFF; /* Marker høyre side */
            align-self: flex-end;
            text-align: right;
        }
        .chat-message span.font-bold {
            color: #00FFFF;
            text-shadow: 0 0 3px rgba(0, 255, 255, 0.5);
        }
        .chat-message span.text-xs {
            color: #9CA3AF; /* Gråere for tid */
        }

        #userChatInputContainer {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        #userChatSendButton {
            background-color: transparent;
            border: 2px solid #00FFFF;
            color: #00FFFF;
            padding: 0.75rem 1.25rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.3);
            border-radius: 0;
            flex-shrink: 0; /* Hindrer krymping */
        }
        #userChatSendButton:hover {
            background-color: #00FFFF;
            color: #000000;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.8), 0 0 20px rgba(0, 255, 255, 0.6);
        }
        #userChatSendButton:active {
            background-color: #00BBBB;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.8);
        }

        #userChatLoadingIndicator {
            color: #00FFFF;
            font-style: italic;
            margin-top: 0.5rem;
            text-align: center;
        }

        #currentUserIdDisplay { /* Changed ID to avoid conflict with currentUserId variable */
            color: #FFFF00; /* Gul for ID for å skille den ut */
            text-shadow: 0 0 5px rgba(255, 255, 0, 0.5);
        }
        #currentNicknameDisplay { /* New element for nickname */
            color: #00FF00; /* Green for nickname */
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
            margin-left: 0.5rem;
        }


        /* Skjul AI Chat i denne layouten for å matche bildet */
        #aiChatContainer {
            display: none !important;
        }

        footer {
            text-align: center;
            margin-top: 2rem;
            font-size: 0.875rem;
            color: #9CA3AF; /* Gråere tekst for mindre viktig info */
        }

        /* Responsive */
        @media (max-width: 640px) {
            body { padding: 0.5rem; }
            .main-wrapper { gap: 1rem; padding: 0.5rem; }
            .retro-box { padding: 1rem; }
            h1 { font-size: 2rem; margin-bottom: 1rem; }
            .game-menu-retro { gap: 1rem; }
            .retro-button { width: 100%; max-width: none; padding: 0.6rem 1rem; }
            .game-area-retro p { font-size: 1.2rem; }
            #userChatOutput { min-height: 100px; }
            #userChatInputContainer { flex-direction: column; gap: 0.5rem; }
            #userChatSendButton { width: 100%; }
            #guessTheNumberGame input[type="number"],
            #questionGame input[type="text"],
            #userChatInput, #loginEmail, #loginPassword, #registerEmail, #registerPassword, #registerNickname {
                max-width: 100%;
            }
            #snakeCanvas, #pongCanvas {
                width: 100%;
                height: auto;
            }
        }

        /* Authentication Modal Styling */
        .auth-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9); /* Semi-transparent black background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it's on top */
            backdrop-filter: blur(5px); /* Optional: blur background content */
        }
        .auth-modal-content {
            composes: retro-box; /* Inherit retro box style */
            padding: 2.5rem;
            max-width: 450px;
            width: 90%;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .auth-modal-content h2 {
            font-size: 2.25rem;
            color: #00FFFF;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.8);
            margin-bottom: 1rem;
            letter-spacing: 0.05em;
        }
        .auth-modal-content input {
            width: 100%;
            margin-bottom: 0.75rem;
        }
        .auth-modal-content button {
            width: 100%;
            margin-top: 0.5rem;
        }
        .auth-toggle {
            color: #FFFF00; /* Yellow link color */
            cursor: pointer;
            text-decoration: underline;
            margin-top: 1rem;
        }
        .auth-error {
            color: #FF00FF; /* Magenta for errors */
            margin-top: 1rem;
            font-size: 0.9rem;
        }

        /* Landing Page Styling */
        #landingPage {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 700px;
            padding: 3rem 2rem;
            z-index: 999; /* Below modal, above main game */
        }
        #landingPage h2 {
            font-size: 2.5rem;
            color: #00FFFF;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            margin-bottom: 1.5rem;
            letter-spacing: 0.08em;
        }
        #landingPage p {
            font-size: 1.25rem;
            color: #00FFFF;
            margin-bottom: 2rem;
            line-height: 1.6;
            letter-spacing: 0.02em;
        }
        #landingPage .retro-button {
            font-size: 1.5rem;
            padding: 1rem 3rem;
        }

        /* Responsive adjustments for landing page */
        @media (max-width: 640px) {
            #landingPage {
                padding: 2rem 1rem;
            }
            #landingPage h2 {
                font-size: 1.8rem;
                margin-bottom: 1rem;
            }
            #landingPage p {
                font-size: 1rem;
                margin-bottom: 1.5rem;
            }
            #landingPage .retro-button {
                font-size: 1.2rem;
                padding: 0.8rem 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="main-wrapper">
        <!-- New Landing Page Section -->
        <div id="landingPage" class="retro-box hidden">
            <h2>VELKOMMEN TIL RETRO MINISPILL ARCADE!</h2>
            <p>
                <span id="userDescriptionText">
                    <!-- Brukerens beskrivelse kommer her -->
                    Dykk inn i en verden av klassiske 1980-talls minispill med en futuristisk vri!
                    Her kan du teste ferdighetene dine i tidløse arkadespill,
                    utfordre venner i fartsfylte kamper, og chatte med andre spillere
                    i vårt unike, neon-fargede terminalmiljø.
                    Gjør deg klar for nostalgi og spenning!
                </span>
            </p>
            <button class="retro-button mt-6" onclick="showAuthModal('login')">START SPILL</button>
        </div>

        <div class="top-box">
            <h1>MINISPILL 1980s</h1>
            <div class="game-menu-retro">
                <button class="retro-button" onclick="loadGame('guessTheNumber')">Gjett Tallet</button>
                <button class="retro-button" onclick="loadGame('pongGame')">Pong</button>
                <button class="retro-button" onclick="loadGame('snakeGame')">Snake</button>
                <!-- Lagt til Question Game tilbake i menyen for enkel tilgang -->
                <button class="retro-button" onclick="loadGame('questionGame')">Spørsmålsspill</button>
            </div>
        </div>

        <main class="game-area-retro" id="gameArea">
            <!-- Spillinnholdet vil lastes inn her via JavaScript -->
            <p>Velg et spill for å starte!</p>
        </main>

        <!-- Bruker Chat er nå den faste bunn-boksen -->
        <div id="userChatContainer" class="bottom-box">
            <h2 class="text-2xl font-bold text-center mb-4" style="color: #00FFFF; text-shadow: 0 0 8px rgba(0, 255, 255, 0.6);">BRUKER CHAT</h2>
            <div id="userChatOutput" class="flex-grow overflow-y-auto mb-4">
                <!-- Bruker chat messages will appear here -->
            </div>
            <p id="userChatLoadingIndicator" class="text-center italic text-gray-400 hidden">SENDER MELDING...</p>
            <div id="userChatInputContainer" class="flex gap-2">
                <input type="text" id="userChatInput" placeholder="SKRIV MELDING..." class="flex-grow">
                <button id="userChatSendButton" onclick="sendMessageUserChat()">SEND</button>
            </div>
            <div class="flex flex-wrap justify-between items-center mt-4 text-sm text-gray-400">
                <span>BRUKER: <span id="currentNicknameDisplay" class="font-mono text-white text-xs break-all">LASTER...</span></span>
                <button onclick="clearUserChat()" class="retro-button px-3 py-1 text-sm">TØM CHAT</button>
                <button onclick="logoutUser()" class="retro-button px-3 py-1 text-sm ml-2">LOGG UT</button>
            </div>
        </div>


        <footer>
            <p>&copy; 2025 MINISPILL ARCADE</p>
        </footer>
    </div>

    <!-- Authentication Modal -->
    <div id="authModal" class="auth-modal hidden">
        <div class="auth-modal-content">
            <div id="loginSection">
                <h2>LOGG INN</h2>
                <input type="email" id="loginEmail" placeholder="E-POST" class="w-full">
                <input type="password" id="loginPassword" placeholder="PASSORD" class="w-full">
                <button onclick="loginUser()">LOGG INN</button>
                <p class="auth-toggle" onclick="toggleAuthMode()">HAR IKKE KONTO? REGISTRER DEG</p>
                <p id="loginError" class="auth-error hidden"></p>
            </div>

            <div id="registerSection" class="hidden">
                <h2>REGISTRER</h2>
                <input type="email" id="registerEmail" placeholder="E-POST" class="w-full">
                <input type="password" id="registerPassword" placeholder="PASSORD" class="w-full">
                <input type="text" id="registerNickname" placeholder="VELG KALLENAVN" class="w-full">
                <button onclick="registerUser()">REGISTRER DEG</button>
                <p class="auth-toggle" onclick="toggleAuthMode()">HAR ALLEREDE KONTO? LOGG INN</p>
                <p id="registerError" class="auth-error hidden"></p>
            </div>
        </div>
    </div>


    <!-- Firebase SDK - IKKE ENDRE URL -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            signInWithCustomToken, 
            onAuthStateChanged,
            createUserWithEmailAndPassword, // Added for registration
            signInWithEmailAndPassword,    // Added for login
            signOut                        // Added for logout
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            getDoc, 
            addDoc, 
            setDoc, 
            updateDoc, 
            deleteDoc, 
            onSnapshot, 
            collection, 
            query, 
            where, 
            orderBy, 
            serverTimestamp, 
            getDocs 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Globala variabler (definieras av Canvas-miljön)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Firebase-initiering
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        let currentUserId = 'anonymous'; // Standardverdi
        let currentNickname = 'LASTER...'; // New: Store current user's nickname
        let unsubscribeUserChat = null; // To manage the chat listener subscription

        // Exposed globally for use in script-tag
        window.db = db;
        window.auth = auth;
        window.currentUserId = currentUserId; // Will be updated on auth state change
        window.currentNickname = currentNickname; // Will be updated
        window.serverTimestamp = serverTimestamp;
        window.collection = collection;
        window.addDoc = addDoc;
        window.query = query;
        window.orderBy = orderBy;
        window.onSnapshot = onSnapshot;
        window.getDocs = getDocs;
        window.doc = doc;
        window.deleteDoc = deleteDoc;
        window.getDoc = getDoc; // Added getDoc

        // --- Authentication Functions ---
        async function authenticateFirebase() {
            // No longer automatically sign in anonymously or with custom token on load
            // The modal will handle login/registration
            console.log("Firebase auth setup. Waiting for user login/registration.");
        }

        onAuthStateChanged(auth, async (user) => {
            const currentNicknameDisplay = document.getElementById('currentNicknameDisplay');
            const authModal = document.getElementById('authModal');
            const landingPage = document.getElementById('landingPage');
            const gameArea = document.getElementById('gameArea'); 
            const topBox = document.querySelector('.top-box'); // Get reference to top box
            const userChatContainer = document.getElementById('userChatContainer');
            const footer = document.querySelector('footer'); // Get reference to footer
            
            if (user) {
                currentUserId = user.uid;
                // Try to fetch nickname
                const nicknameDocRef = doc(db, `artifacts/${appId}/public/data/nicknames`, currentUserId);
                const nicknameDocSnap = await getDoc(nicknameDocRef);

                if (nicknameDocSnap.exists()) {
                    currentNickname = nicknameDocSnap.data().nickname;
                    landingPage.classList.add('hidden'); // Hide landing page
                    authModal.classList.add('hidden'); // Hide modal
                    gameArea.classList.remove('hidden'); // Show game area
                    topBox.classList.remove('hidden'); // Show top box
                    userChatContainer.classList.remove('hidden'); // Show chat container
                    footer.classList.remove('hidden'); // Show footer
                    setupUserChatListener(); // Start chat listener
                } else {
                    // If user exists but no nickname is set (e.g., migrated from anonymous or new Email/Password user without nickname)
                    // Prompt for nickname if not set
                    if (currentNicknameDisplay) currentNicknameDisplay.textContent = 'VELG NICK...'; // Show temporary state
                    showAuthModal('register', true); // Force register view to get nickname
                    landingPage.classList.add('hidden'); // Ensure landing page is hidden
                    gameArea.classList.add('hidden'); // Ensure game area is hidden
                    topBox.classList.add('hidden'); // Ensure top box is hidden
                    userChatContainer.classList.add('hidden'); // Ensure chat is hidden
                    footer.classList.add('hidden'); // Ensure footer is hidden
                    console.warn("User logged in but no nickname found. Prompting for nickname.");
                    return; // Prevent further chat setup until nickname is chosen
                }

                if (currentNicknameDisplay) currentNicknameDisplay.textContent = currentNickname.toUpperCase();
                console.log(`Firebase autentisert. Bruker-ID: ${currentUserId}, Kallenavn: ${currentNickname}`);
            } else {
                currentUserId = 'anonymous';
                currentNickname = 'GJEST'; // Fallback
                if (currentNicknameDisplay) currentNicknameDisplay.textContent = currentNickname;
                console.log("Firebase: Ingen bruker logget inn.");
                // Unsubscribe chat listener if user logs out
                if (unsubscribeUserChat) {
                    unsubscribeUserChat();
                    unsubscribeUserChat = null;
                    console.log("Chat listener unsubscribed.");
                }
                // Show landing page if not logged in, hide game area and auth modal
                gameArea.classList.add('hidden');
                authModal.classList.add('hidden'); 
                landingPage.classList.remove('hidden'); // Show landing page
                topBox.classList.add('hidden'); // Ensure top box is hidden
                userChatContainer.classList.add('hidden'); // Ensure chat is hidden
                footer.classList.add('hidden'); // Ensure footer is hidden
            }
        });

        // Expose login/register/logout globally
        window.loginUser = loginUser;
        window.registerUser = registerUser;
        window.logoutUser = logoutUser;
        window.toggleAuthMode = toggleAuthMode;
        window.showAuthModal = showAuthModal; // Expose showAuthModal for landing page button

        async function registerUser() {
            const email = document.getElementById('registerEmail').value;
            const password = document.getElementById('registerPassword').value;
            const nickname = document.getElementById('registerNickname').value.trim();
            const registerError = document.getElementById('registerError');

            registerError.classList.add('hidden'); // Clear previous errors

            if (!email || !password || !nickname) {
                registerError.textContent = "ALLE FELT MÅ FYLLES UT.";
                registerError.classList.remove('hidden');
                return;
            }
            if (password.length < 6) {
                registerError.textContent = "PASSORD MÅ VÆRE MINST 6 TEGN.";
                registerError.classList.remove('hidden');
                return;
            }

            // Check if nickname already exists
            const nicknamesRef = collection(db, `artifacts/${appId}/public/data/nicknames`);
            const q = query(nicknamesRef, where("nickname", "==", nickname));
            const querySnapshot = await getDocs(q);

            if (!querySnapshot.empty) {
                registerError.textContent = "KALLENAVN ER ALLEREDE TATT. VELG ET ANNET.";
                registerError.classList.remove('hidden');
                return;
            }

            try {
                const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                const user = userCredential.user;
                
                // Store nickname in Firestore
                await setDoc(doc(db, `artifacts/${appId}/public/data/nicknames`, user.uid), {
                    nickname: nickname,
                    createdAt: serverTimestamp()
                });

                console.log("Bruker registrert og kallenavn satt:", user.uid, nickname);
                // onAuthStateChanged will handle hiding modal and setting up chat
            } catch (error) {
                console.error("Registreringsfeil:", error.message);
                registerError.textContent = `FEIL: ${error.message.toUpperCase()}`;
                registerError.classList.remove('hidden');
            }
        }

        async function loginUser() {
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            const loginError = document.getElementById('loginError');

            loginError.classList.add('hidden'); // Clear previous errors

            if (!email || !password) {
                loginError.textContent = "E-POST OG PASSORD MÅ FYLLES UT.";
                loginError.classList.remove('hidden');
                return;
            }

            try {
                await signInWithEmailAndPassword(auth, email, password);
                console.log("Bruker logget inn.");
                // onAuthStateChanged will handle hiding modal and setting up chat
            } catch (error) {
                console.error("Innloggingsfeil:", error.message);
                loginError.textContent = `FEIL: ${error.message.toUpperCase()}`;
                loginError.classList.remove('hidden');
            }
        }

        async function logoutUser() {
            try {
                await signOut(auth);
                console.log("Bruker logget ut.");
                // onAuthStateChanged will handle showing modal
            } catch (error) {
                console.error("Feil ved utlogging:", error.message);
                // Using a custom message box instead of alert()
                const errorMessageDiv = document.createElement('div');
                errorMessageDiv.className = "fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50";
                errorMessageDiv.innerHTML = `
                    <div class="retro-box p-8 max-w-sm mx-auto text-center">
                        <p class="mb-4" style="color: #FF00FF;">FEIL VED UTLOGGING: ${error.message.toUpperCase()}</p>
                        <button id="closeErrorBtn" class="retro-button">OK</button>
                    </div>
                `;
                document.body.appendChild(errorMessageDiv);
                document.getElementById('closeErrorBtn').onclick = () => {
                    document.body.removeChild(errorMessageDiv);
                };
            }
        }

        // --- Auth Modal Control ---
        let forceRegister = false; // Flag to force register view if nickname is missing

        function showAuthModal(mode = 'login', force = false) {
            const authModal = document.getElementById('authModal');
            const loginSection = document.getElementById('loginSection');
            const registerSection = document.getElementById('registerSection');
            const landingPage = document.getElementById('landingPage'); // Get reference
            
            forceRegister = force;

            if (mode === 'login' && !forceRegister) {
                loginSection.classList.remove('hidden');
                registerSection.classList.add('hidden');
            } else {
                loginSection.classList.add('hidden');
                registerSection.classList.remove('hidden');
            }
            
            // Hide landing page when showing auth modal
            landingPage.classList.add('hidden');
            authModal.classList.remove('hidden');
        }

        function toggleAuthMode() {
            if (forceRegister) return; // Cannot toggle if forced to register (missing nickname)
            const loginSection = document.getElementById('loginSection');
            const registerSection = document.getElementById('registerSection');
            loginSection.classList.toggle('hidden');
            registerSection.classList.toggle('hidden');
            document.getElementById('loginError').classList.add('hidden');
            document.getElementById('registerError').classList.add('hidden');
        }


        // --- Referanse til spillområdet ---
        // These are now initialized based on the auth state, not hidden by default here
        const gameArea = document.getElementById('gameArea');
        const userChatContainer = document.getElementById('userChatContainer');
        const topBox = document.querySelector('.top-box'); // Get reference to top box
        const footer = document.querySelector('footer'); // Get reference to footer

        // requestAnimationFrame ID for Pong, so it can be cancelled
        let pongAnimationFrameId = null;
        // Flag to prevent adding multiple event listeners for Pong controls
        let pongEventListenersAdded = false;

        // Funksjon for å laste et spill inn i spillområdet
        function loadGame(gameName) {
            gameArea.innerHTML = ''; // Tømmer spillområdet
            // Stopp alle aktive spill-looper før et nytt spill lastes
            stopAllGameLoops();

            // Sørg for at spillområdet alltid er synlig i denne layouten
            gameArea.classList.remove('hidden');

            switch (gameName) {
                case 'guessTheNumber':
                    loadGuessTheNumberGame();
                    break;
                case 'questionGame': 
                    loadQuestionGame();
                    break;
                case 'retroGames': // Denne knappen er nå fjernet fra main menu
                    loadRetroGamesMenu();
                    break;
                case 'snakeGame':
                    loadSnakeGame();
                    break;
                case 'pongGame':
                    loadPongGame();
                    break;
                // AI Chat og Bruker Chat er nå faste elementer, ikke lastet inn i gameArea
                default:
                    gameArea.innerHTML = '<p>Velg et spill for å starte!</p>';
            }
        }

        // Funksjon for å stoppe alle aktive spill-looper
        function stopAllGameLoops() {
            // Snake game loop
            if (snakeGameLoopId) {
                clearTimeout(snakeGameLoopId);
                snakeGameLoopId = null;
            }
            // Pong game loop
            if (pongAnimationFrameId) {
                cancelAnimationFrame(pongAnimationFrameId);
                pongAnimationFrameId = null;
            }
            // Fjern event listeners for spillkontroller
            document.removeEventListener('keydown', changeDirection); // For Snake
            // Only remove Pong listeners if they were actually added
            if (pongEventListenersAdded) {
                document.removeEventListener('keydown', handlePongKeyPress);
                document.removeEventListener('keyup', handlePongKeyRelease);
                pongEventListenersAdded = false; // Reset flag
            }
        }


        // --- Gjett Tallet-spillet ---
        function loadGuessTheNumberGame() {
            gameArea.innerHTML = `
                <div id="guessTheNumberGame" class="w-full max-w-md p-4 flex flex-col items-center">
                    <h2>GJETT TALLET!</h2>
                    <p class="text-lg mb-4 mt-4">JEG TENKER PÅ ET TALL MELLOM 1 OG 100.</p>
                    <input type="number" id="guessInput" placeholder="SKRIV INN DITT GJETNING" min="1" max="100" class="w-full max-w-xs">
                    <button onclick="checkGuess()" class="mt-4 w-full max-w-xs">GJETT!</button>
                    <p id="gameMessage" class="text-gray-200 mt-4"></p>
                    <p id="attemptsCount" class="text-gray-400"></p>
                    <button onclick="resetGuessTheNumberGame()" class="mt-6 w-full max-w-xs">START NYTT SPILL</button>
                </div>
            `;

            secretNumber = generateRandomNumber(1, 100);
            attempts = 0;
            updateGuessTheNumberUI();
            console.log("Secret number (for testing):", secretNumber);
        }

        let secretNumber;
        let attempts;

        function generateRandomNumber(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function updateGuessTheNumberUI() {
            document.getElementById('attemptsCount').textContent = `ANTALL FORSØK: ${attempts}`;
        }

        function checkGuess() {
            const guessInput = document.getElementById('guessInput');
            const gameMessage = document.getElementById('gameMessage');
            const guess = parseInt(guessInput.value);

            if (isNaN(guess) || guess < 1 || guess > 100) {
                gameMessage.textContent = "VENNLIGST SKRIV INN ET GYLDIG TALL MELLOM 1 OG 100.";
                gameMessage.style.color = '#FF00FF'; /* Magenta for feil */
                return;
            }

            attempts++;
            updateGuessTheNumberUI();

            if (guess === secretNumber) {
                gameMessage.textContent = `GRATULERER! DU GJETTET RIKTIG TALL (${secretNumber}) PÅ ${attempts} FORSØK!`;
                gameMessage.style.color = '#00FF00'; /* Grønn for riktig */
                guessInput.disabled = true;
            } else if (guess < secretNumber) {
                gameMessage.textContent = "FOR LAVT! PRØV ET HØYERE TALL.";
                gameMessage.style.color = '#FFFF00'; /* Gul for hint */
            } else {
                gameMessage.textContent = "FOR HØYT! PRØV ET LAVERE TALL.";
                gameMessage.style.color = '#FFFF00'; /* Gul for hint */
            }

            guessInput.value = '';
            guessInput.focus();
        }

        function resetGuessTheNumberGame() {
            secretNumber = generateRandomNumber(1, 100);
            attempts = 0;
            document.getElementById('guessInput').value = '';
            document.getElementById('guessInput').disabled = false;
            document.getElementById('gameMessage').textContent = '';
            updateGuessTheNumberUI();
            console.log("Secret number (for testing):", secretNumber);
        }

        // --- Spørsmålsspillet (Ikke lenger i meny, men beholdt funksjonalitet) ---
        let questions = [];
        let currentQuestionIndex;
        let correctAnswers = 0;
        let totalQuestionsAsked = 0;
        const LEADERBOARD_KEY = 'questionGameLeaderboard';

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function loadQuestionGame() {
            gameArea.innerHTML = `
                <div id="questionGame" class="w-full max-w-lg p-4 flex flex-col items-center">
                    <h2>SPØRSMÅLSSPILL!</h2>
                    <p id="questionDisplay" class="mb-4 mt-4"></p>
                    <input type="text" id="answerInput" placeholder="SKRIV INN DITT SVAR HER" class="w-full max-w-md">
                    <div class="button-group flex justify-center mt-4 gap-4">
                        <button onclick="checkQuestionAnswer()">SVAR</button>
                        <button onclick="nextQuestion()">NESTE SPØRSMÅL</button>
                    </div>
                    <p id="answerMessage" class="text-gray-200 mt-4"></p>
                    <p id="scoreDisplay" class="text-gray-400 mt-2">POENG: 0 / 0</p>
                    <button onclick="resetQuestionGame()" class="mt-6 w-full max-w-xs">START NYTT SPILL</button>
                </div>

                <div id="leaderboard-container" class="mt-8 retro-box w-full max-w-md">
                    <h3 class="text-xl font-bold text-center" style="color: #00FFFF; text-shadow: 0 0 5px rgba(0, 255, 255, 0.6);">RESULTATLISTE</h3>
                    <ol id="leaderboardList" class="mt-4"></ol>
                </div>
            `;

            initializeQuestionGame();
            loadAndDisplayLeaderboard();
        }

        function initializeQuestionGame() {
            const allQuestions = [
                { question: "HVA ER HOVEDSTADEN I NORGE?", answer: "Oslo" },
                { question: "HVILKET GRUNNSTOFF HAR KJEMISK SYMBOL 'O'?", answer: "Oksygen" },
                { question: "HVA HETER VERDENS STØRSTE HAV?", answer: "Stillehavet" },
                { question: "HVILKEN PLANET ER KJENT SOM 'DEN RØDE PLANET'?", answer: "Mars" },
                { question: "HVEM SKREV 'PEER GYNT'?", answer: "Henrik Ibsen" },
                { question: "HVOR MANGE DAGER ER DET I ET SKUDDÅR?", answer: "366" },
                { question: "HVA ER RESULTATET AV 7 X 8?", answer: "56" },
                { question: "HVILKEN FUGL ER ET SYMBOL FOR FRED?", answer: "Due" },
                { question: "HVA HETER DEN HØYESTE FJELLTOPPEN I VERDEN?", answer: "Mount Everest" },
                { question: "HVILKET DYR GIR OSS ULL?", answer: "Sau" },
                { question: "HVA HETER NORGES LENGSTE ELV?", answer: "Glomma" },
                { question: "HVILKEN FARGE FÅR DU HVIS DU BLANDER BLÅTT OG GULT?", answer: "Grønn" },
                { question: "HVA HETER DET STØRSTE ORGANET I MENNESKEKROPPEN?", answer: "Hud" },
                { question: "HVA HETER VALUTAEN I JAPAN?", answer: "Yen" },
                { question: "HVILKEN SPORT BRUKER EN PUCK?", answer: "Ishockey" },
                { question: "HVA ER HOVEDSTADEN I SVERIGE?", answer: "Stockholm" },
                { question: "HVILKEN MÅNED HAR 28 DAGER (UTENOM SKUDDÅR)?", answer: "Februar" },
                { question: "HVA HETER DYRET SOM ER EN 'KONGLE-SPISER'?", answer: "Eikenøtt" },
                { question: "HVA ER MOTSATT AV 'KALD'?", answer: "Varm" },
                { question: "HVILKEN BY ER KJENT FOR EIFFELTÅRNET?", answer: "Paris" },
                { question: "HVA HETER HAVNEN I BERGEN?", answer: "Bryggen" },
                { question: "HVILKET INSTRUMENT HAR 88 TANGENTER?", answer: "Piano" },
                { question: "HVA ER ET ANNET NAVN FOR ET 'SEKSKANTET' OBJEKT?", answer: "Heksagon" },
                { question: "HVILKEN TYPE FRUKT ER EN BANAN?", answer: "Bær" },
                { question: "HVA ER DEN STØRSTE ØRKENEN I VERDEN?", answer: "Sahara" },
                { question: "HVEM MALTE 'SKRIK'?", answer: "Edvard Munch" },
                { question: "HVA HETER NORGES NASJONALFUGL?", answer: "Fossekall" },
                { question: "HVOR MANGE BEIN HAR EN EDDERKOPP?", answer: "8" },
                { question: "HVA ER DEN OFFISIELLE HOVEDSTADEN I CANADA?", answer: "Ottawa" },
                { question: "HVILKET HAV SKILLER EUROPA OG AFRIKA?", answer: "Middelhavet" },
                { question: "HVA HETER FIKTIVE KARAKTEREN SOM BOR I EN ANANAS UNDER HAVET?", answer: "Svampebob Firkant" },
                { question: "HVA ER DET HØYESTE BYGGET I VERDEN?", answer: "Burj Khalifa" },
                { question: "HVILKEN FARGE ER SOLSIKKER?", answer: "Gul" },
                { question: "HVA HETER DET FØRSTE MENNESKET PÅ MÅNEN?", answer: "Neil Armstrong" },
                { question: "HVILKET LAND ER KJENT FOR PIZZA OG PASTA?", answer: "Italia" },
                { question: "HVA ER EN GRUPPE LØVER KALT?", answer: "Stolthet" },
                { question: "HVILKEN METALL ER FLYTENDE VED ROMTEMPERATUR?", answer: "Kvikksølv" },
                { question: "HVA ER HOVEDSTADEN I TYSKLAND?", answer: "Berlin" },
                { question: "HVA HETER DET STØRSTE PATTEDYR I VERDEN?", answer: "Blåhval" },
                { question: "HVA ER DET MEST VANLIGE NAVNET I VERDEN?", answer: "Mohammed" },
                { question: "HVA HETER ELVEN SOM RENNER GJENNOM LONDON?", answer: "Themsen" },
                { question: "HVA ER DET MINSTE LANDET I VERDEN?", answer: "Vatikanstaten" },
                { question: "HVA HETER DEN STØRSTE ØYA I VERDEN?", answer: "Grønland" },
                { question: "HVA ER HOVEDINGREDIENSEN I GUACAMOLE?", answer: "Avocado" },
                { question: "HVILKEN PLANET ER NÆRMEST SOLEN?", answer: "Mercur" },
                { question: "HVA ER DET KJEMISKE SYMBOLET FOR VANN?", answer: "H2O" },
                { question: "HVILKEN FARGE ER HIMMELEN PÅ EN KLAR DAG?", answer: "Blå" },
                { question: "HVILKET DYR ER KJENT FOR Å BYGGE DEMNINGER?", answer: "Bever" },
                { question: "HVA HETER SPORTEN DER MAN KASTER EN JAVELIN?", answer: "Spydkast" },
                { question: "HVILKEN DEL AV ET TRE LEDER VANN OPP TIL BLADENE?", answer: "Stamme" }
            ];

            questions = [...allQuestions];
            shuffleArray(questions);
            currentQuestionIndex = -1;
            correctAnswers = 0;
            totalQuestionsAsked = 0;
            nextQuestion();
            updateQuestionScore();
        }

        // Added missing displayQuestion function
        function displayQuestion() {
            const questionDisplay = document.getElementById('questionDisplay');
            const answerInput = document.getElementById('answerInput');
            const answerMessage = document.getElementById('answerMessage');

            if (currentQuestionIndex < questions.length) {
                questionDisplay.textContent = questions[currentQuestionIndex].question.toUpperCase();
                answerInput.value = '';
                answerInput.disabled = false;
                answerInput.focus();
                answerMessage.textContent = ''; // Clear previous message
            } else {
                questionDisplay.textContent = "INGEN FLERE SPØRSMÅL! SPILL OVER.";
                answerInput.disabled = true;
                showNicknameInput(); // Prompt for nickname after game ends
            }
        }

        function checkQuestionAnswer() {
            const answerInput = document.getElementById('answerInput');
            const answerMessage = document.getElementById('answerMessage');
            const userAnswer = answerInput.value.trim().toLowerCase();
            const correctAnswer = questions[currentQuestionIndex].answer.trim().toLowerCase();

            if (answerInput.disabled) {
                return;
            }

            totalQuestionsAsked++;

            if (userAnswer === correctAnswer) {
                answerMessage.textContent = "RIKTIG SVAR! 🎉";
                answerMessage.style.color = '#00FF00'; /* Grønn */
                correctAnswers++;
            } else {
                answerMessage.textContent = `FEIL SVAR. SVARET VAR: ${questions[currentQuestionIndex].answer.toUpperCase()}`;
                answerMessage.style.color = '#FF00FF'; /* Magenta */
            }
            answerInput.disabled = true;
            updateQuestionScore();
        }

        function nextQuestion() {
            const answerMessage = document.getElementById('answerMessage');
            const answerInput = document.getElementById('answerInput');

            if (currentQuestionIndex >= 0 && !answerInput.disabled && currentQuestionIndex < questions.length) {
                 totalQuestionsAsked++;
                 answerMessage.textContent = `DU HOPPET OVER DETTE. SVARET VAR: ${questions[currentQuestionIndex].answer.toUpperCase()}`;
                 answerMessage.style.color = '#FFFF00'; /* Gul */
                 updateQuestionScore();
            }

            currentQuestionIndex++;
            displayQuestion();
        }

        function updateQuestionScore() {
            document.getElementById('scoreDisplay').textContent = `POENG: ${correctAnswers} / ${totalQuestionsAsked}`;
        }

        function resetQuestionGame() {
            initializeQuestionGame();
            document.getElementById('answerMessage').textContent = '';
            // Remove nickname input container if it exists
            const nicknameInputContainer = document.getElementById('nicknameInputContainer');
            if (nicknameInputContainer) {
                nicknameInputContainer.remove();
            }
        }

        // --- Resultatliste (Leaderboard) funksjoner ---
        function getLeaderboard() {
            const leaderboardJson = localStorage.getItem(LEADERBOARD_KEY);
            return leaderboardJson ? JSON.parse(leaderboardJson) : [];
        }

        function saveLeaderboard(leaderboardData) {
            localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(leaderboardData));
        }

        function addScoreToLeaderboard(nickname, score, total) {
            let leaderboard = getLeaderboard();
            leaderboard.push({ nickname: nickname, score: score, totalQuestions: total });

            leaderboard.sort((a, b) => {
                if (b.score !== a.score) {
                    return b.score - a.score;
                }
                // If scores are equal, sort by fewer questions asked (more efficient)
                return a.totalQuestions - b.totalQuestions;
            });

            leaderboard = leaderboard.slice(0, 5); // Keep only top 5
            saveLeaderboard(leaderboard);
            loadAndDisplayLeaderboard();
        }

        function loadAndDisplayLeaderboard() {
            const leaderboardList = document.getElementById('leaderboardList');
            if (!leaderboardList) return;

            const leaderboard = getLeaderboard();
            leaderboardList.innerHTML = '';

            if (leaderboard.length === 0) {
                leaderboardList.innerHTML = '<li class="text-center text-gray-400">INGEN RESULTATER ENNÅ. SPILL FOR Å KOMME PÅ LISTEN!</li>';
                return;
            }

            leaderboard.forEach((entry, index) => {
                const listItem = document.createElement('li');
                listItem.className = "flex justify-between items-center bg-transparent border-b border-dashed border-gray-700 py-1";
                listItem.innerHTML = `
                    <span class="text-cyan-400">${index + 1}. ${entry.nickname.toUpperCase()}</span>
                    <span class="text-yellow-400">${entry.score} / ${entry.totalQuestions}</span>
                `;
                leaderboardList.appendChild(listItem);
            });
        }

        function showNicknameInput() {
            const questionGameDiv = document.getElementById('questionGame');
            // Remove existing nickname input container to prevent duplicates
            const existingNicknameInput = document.getElementById('nicknameInputContainer');
            if (existingNicknameInput) {
                existingNicknameInput.remove();
            }

            const nicknameInputContainer = document.createElement('div');
            nicknameInputContainer.id = 'nicknameInputContainer';
            nicknameInputContainer.className = 'mt-6 retro-box w-full max-w-md p-4';
            nicknameInputContainer.innerHTML = `
                <p class="text-center mb-2">GRATULERER! SKRIV INN DITT KALLENAVN FOR RESULTATLISTEN:</p>
                <input type="text" id="nicknameInput" placeholder="KALLENAVN" class="w-full mb-2">
                <button onclick="submitNickname()" class="w-full">LAGRE POENGSUM</button>
            `;
            questionGameDiv.appendChild(nicknameInputContainer);
            document.getElementById('nicknameInput').focus();
        }

        function submitNickname() {
            const nicknameInput = document.getElementById('nicknameInput');
            let nickname = nicknameInput.value.trim();

            if (nickname === "") {
                nickname = "ANONYM";
            }

            addScoreToLeaderboard(nickname, correctAnswers, totalQuestionsAsked);

            const nicknameInputContainer = document.getElementById('nicknameInputContainer');
            if (nicknameInputContainer) {
                nicknameInputContainer.remove();
            }
            const answerMessage = document.getElementById('answerMessage');
            answerMessage.textContent = `POENGSUM LAGRET UNDER ${nickname.toUpperCase()}!`;
            answerMessage.style.color = '#00FF00';
        }

        // --- Retro Games Menu (Ikke lenger i meny, men beholdt funksjonalitet) ---
        function loadRetroGamesMenu() {
            gameArea.innerHTML = `
                <div class="w-full max-w-2xl p-4">
                    <h2 class="text-3xl font-bold text-center mb-6">90-TALLS RETRO SPILL</h2>
                    <div class="game-menu-retro">
                        <button class="retro-button" onclick="loadGame('snakeGame')">SNAKE</button>
                        <button class="retro-button" onclick="loadGame('pongGame')">PONG</button>
                        <button class="retro-button" disabled>TETRIS LITE (KOMMER)</button>
                        <button class="retro-button" disabled>PAC-MAN LITE (KOMMER)</button>
                        <button class="retro-button" disabled>SPACE INVADERS LITE (KOMMER)</button>
                        <button class="retro-button" disabled>BRICK BREAKER (KOMMER)</button>
                        <button class="retro-button" disabled>FROGGER LITE (KOMMER)</button>
                        <button class="retro-button" disabled>CONNECT FOUR (KOMMER)</button>
                        <button class="retro-button" disabled>TIC-TAC-TOE (KOMMER)</button>
                        <button class="retro-button" disabled>MINESWEEPER LITE (KOMMER)</button>
                        <button class="retro-button" disabled>SIMON SAYS (KOMMER)</button>
                        <button class="retro-button" disabled>WHACK-A-MOLE (KOMMER)</button>
                        <button class="retro-button" disabled>FLAPPY BIRD (KOMMER)</button>
                        <button class="retro-button" disabled>CROSSY ROAD (KOMMER)</button>
                        <button class="retro-button" disabled>ENDLESS RUNNER (KOMMER)</button>
                        <button class="retro-button" disabled>PINBALL LITE (KOMMER)</button>
                        <button class="retro-button" disabled>HANGMAN (KOMMER)</button>
                        <button class="retro-button" disabled>GUESS THE WORD (KOMMER)</button>
                        <button class="retro-button" disabled>ROCK-PAPER-SCISSORS (KOMMER)</button>
                        <button class="retro-button" disabled>MEMORY GAME (KOMMER)</button>
                        <button class="retro-button" disabled>SUDOKU (KOMMER)</button>
                        <button class="retro-button" disabled>BATTLESHIP LITE (KOMMER)</button>
                        <button class="retro-button" disabled>MASTERMIND (KOMMER)</button>
                        <button class="retro-button" disabled>2048 (KOMMER)</button>
                        <button class="retro-button" disabled>DOODLE JUMP (KOMMER)</button>
                    </div>
                </div>
            `;
        }


        // --- Snake Game ---
        let snakeCanvas, snakeCtx;
        const GRID_SIZE = 20;
        let snake = [{ x: 10, y: 10 }];
        let food = {};
        let dx = 0;
        let dy = 0;
        let score = 0;
        let changingDirection = false;
        let snakeGameLoopId = null;

        function loadSnakeGame() {
            gameArea.innerHTML = `
                <div id="snakeGame" class="w-full max-w-lg p-4 flex flex-col items-center">
                    <h2>SNAKE</h2>
                    <canvas id="snakeCanvas" width="400" height="400"></canvas>
                    <div id="snakeGameControls" class="mt-4 flex gap-4">
                        <button onclick="startGame()">START SPILL</button>
                        <button onclick="pauseGame()">PAUSE/FORTSETT</button>
                        <button onclick="resetSnakeGame()">NYTT SPILL</button>
                    </div>
                    <p id="snakeScore" class="mt-4">POENG: 0</p>
                </div>
            `;
            snakeCanvas = document.getElementById('snakeCanvas');
            snakeCtx = snakeCanvas.getContext('2d');
            resetSnakeGame();
            // Ensure event listener is added only once
            document.removeEventListener('keydown', changeDirection); // Remove existing to prevent duplicates
            document.addEventListener('keydown', changeDirection);
        }

        function createFood() {
            food = {
                x: Math.floor(Math.random() * (snakeCanvas.width / GRID_SIZE)),
                y: Math.floor(Math.random() * (snakeCanvas.height / GRID_SIZE))
            };
            snake.forEach(part => {
                if (part.x === food.x && part.y === food.y) {
                    createFood(); // Recalculate if food spawns on snake
                }
            });
        }

        function drawSnakePart(snakePart) {
            snakeCtx.fillStyle = '#00FF00'; /* Neon grønn for slange */
            snakeCtx.strokeStyle = '#00BB00'; /* Mørkere grønn */
            snakeCtx.fillRect(snakePart.x * GRID_SIZE, snakePart.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
            snakeCtx.strokeRect(snakePart.x * GRID_SIZE, snakePart.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
        }

        function drawFood() {
            snakeCtx.fillStyle = '#FF00FF'; /* Neon magenta for mat */
            snakeCtx.strokeStyle = '#BB00BB';
            snakeCtx.fillRect(food.x * GRID_SIZE, food.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
            snakeCtx.strokeRect(food.x * GRID_SIZE, food.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
        }

        function draw() {
            snakeCtx.clearRect(0, 0, snakeCanvas.width, snakeCanvas.height);
            drawFood();
            snake.forEach(drawSnakePart);
        }

        function advanceSnake() {
            // Prevent snake from moving if game isn't started (dx, dy are 0)
            if (snakeGameLoopId === null && (dx === 0 && dy === 0)) return;

            const head = { x: snake[0].x + dx, y: snake[0].y + dy };

            // Check for collision with walls or self
            if (
                head.x < 0 || head.x * GRID_SIZE >= snakeCanvas.width ||
                head.y < 0 || head.y * GRID_SIZE >= snakeCanvas.height ||
                checkCollision(head)
            ) {
                gameOver("GAME OVER! DITT POENG: " + score);
                return;
            }

            snake.unshift(head); // Add new head

            const didEatFood = head.x === food.x && head.y === food.y;
            if (didEatFood) {
                score += 10;
                document.getElementById('snakeScore').textContent = `POENG: ${score}`;
                createFood(); // Generate new food
            } else {
                snake.pop(); // Remove tail if no food eaten
            }
            changingDirection = false; // Allow new direction input
        }

        function checkCollision(head) {
            // Check if the new head position collides with any part of the snake's body
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) return true;
            }
            return false;
        }

        function changeDirection(event) {
            const LEFT_KEY = 37;
            const RIGHT_KEY = 39;
            const UP_KEY = 38;
            const DOWN_KEY = 40;

            // Prevent rapid direction changes that can lead to immediate self-collision
            if (changingDirection) return;
            changingDirection = true;

            const keyPressed = event.keyCode;
            const goingUp = dy === -1;
            const goingDown = dy === 1;
            const goingLeft = dx === -1;
            const goingRight = dx === 1;

            if (keyPressed === LEFT_KEY && !goingRight) {
                dx = -1;
                dy = 0;
            }
            if (keyPressed === UP_KEY && !goingDown) {
                dx = 0;
                dy = -1;
            }
            if (keyPressed === RIGHT_KEY && !goingLeft) {
                dx = 1;
                dy = 0;
            }
            if (keyPressed === DOWN_KEY && !goingUp) {
                dx = 0;
                dy = 1;
            }
        }

        function gameLoop() {
            // Use setTimeout for a fixed game speed for Snake
            snakeGameLoopId = setTimeout(function onTick() {
                advanceSnake();
                draw();
                gameLoop();
            }, 100); // 100ms interval for movement
        }

        function startGame() {
            // Start the game loop if it's not already running
            if (snakeGameLoopId === null) {
                if (dx === 0 && dy === 0) {
                     dx = 1; // Initial direction if not set
                }
                gameLoop();
            }
        }

        function pauseGame() {
            if (snakeGameLoopId) {
                clearTimeout(snakeGameLoopId);
                snakeGameLoopId = null;
            } else {
                startGame(); // Resume game
            }
        }

        function resetSnakeGame() {
            clearTimeout(snakeGameLoopId); // Stop any active loop
            snakeGameLoopId = null;
            snake = [{ x: 10, y: 10 }]; // Reset snake position
            dx = 0; // Reset direction
            dy = 0;
            score = 0; // Reset score
            document.getElementById('snakeScore').textContent = `POENG: ${score}`;
            createFood(); // Create new food
            draw(); // Draw initial state
        }

        function gameOver(message) {
            clearTimeout(snakeGameLoopId); // Stop game loop
            snakeGameLoopId = null;
            document.getElementById('snakeScore').textContent = message; // Display game over message
        }

        // --- Pong Game ---
        let pongCanvas, pongCtx;
        let paddle1, paddle2, ball;
        let player1Score, player2Score;
        let pongMessageElement;
        let pongScoreElement;

        const keysPressed = {}; // Keep track of currently pressed keys for smooth movement

        function loadPongGame() {
            gameArea.innerHTML = `
                <div id="pongGame" class="w-full max-w-lg p-4 flex flex-col items-center">
                    <h2>PONG</h2>
                    <canvas id="pongCanvas" width="500" height="300"></canvas>
                    <div id="pongGameControls" class="mt-4 flex gap-4">
                        <button onclick="startGamePong()">START SPILL</button>
                        <button onclick="resetPongGame()">NYTT SPILL</button>
                    </div>
                    <p id="pongScore" class="mt-4">POENG: SPILLER 1: 0 - SPILLER 2: 0</p>
                    <p id="pongMessage" class="mt-2"></p>
                    <div class="pong-controls-info">
                        <p>KONTROLLER:</p>
                        <p>SPILLER 1 (VENSTRE): W (OPP), S (NED)</p>
                        <p>SPILLER 2 (HØYRE): PIL OPP, PIL NED</p>
                    </div>
                </div>
            `;
            pongCanvas = document.getElementById('pongCanvas');
            pongCtx = pongCanvas.getContext('2d');
            pongMessageElement = document.getElementById('pongMessage');
            pongScoreElement = document.getElementById('pongScore');

            // Add event listeners only once for Pong
            if (!pongEventListenersAdded) {
                document.addEventListener('keydown', handlePongKeyPress);
                document.addEventListener('keyup', handlePongKeyRelease);
                pongEventListenersAdded = true;
            }

            resetPongGame();
        }

        function initPongObjects() {
            // Initialize paddle and ball positions and properties
            paddle1 = { x: 10, y: pongCanvas.height / 2 - 30, width: 10, height: 60, dy: 0, color: '#00FFFF' }; /* Neon cyan */
            paddle2 = { x: pongCanvas.width - 20, y: pongCanvas.height / 2 - 30, width: 10, height: 60, dy: 0, color: '#FF00FF' }; /* Neon magenta */
            ball = { x: pongCanvas.width / 2, y: pongCanvas.height / 2, radius: 7, dx: 0, dy: 0, color: '#FFFF00' }; /* Neon gul */
        }

        function resetPongGame() {
            if (pongAnimationFrameId) {
                cancelAnimationFrame(pongAnimationFrameId); // Stop any active animation
            }
            pongAnimationFrameId = null; // Clear animation frame ID

            player1Score = 0;
            player2Score = 0;
            updatePongScore();
            pongMessageElement.textContent = "TRYKK 'START SPILL' FOR Å BEGYNNE!";
            initPongObjects(); // Re-initialize positions
            drawPong(); // Draw initial state
        }

        function serveBall() {
            // Reset ball position to center and give it a random initial direction
            ball.x = pongCanvas.width / 2;
            ball.y = pongCanvas.height / 2;
            // Random horizontal direction (left or right) and some vertical angle
            ball.dx = (Math.random() > 0.5 ? 3 : -3) * (Math.random() > 0.5 ? 1 : 1);
            ball.dy = (Math.random() * 2 - 1) * 2;
        }

        function drawPong() {
            // Clear canvas and draw background
            pongCtx.fillStyle = 'black';
            pongCtx.fillRect(0, 0, pongCanvas.width, pongCanvas.height);

            // Draw middle line
            pongCtx.strokeStyle = '#00FFFF'; /* Neon cyan midtlinje */
            pongCtx.beginPath();
            pongCtx.setLineDash([5, 5]); // Dashed line
            pongCtx.moveTo(pongCanvas.width / 2, 0);
            pongCtx.lineTo(pongCanvas.width / 2, pongCanvas.height);
            pongCtx.stroke();
            pongCtx.setLineDash([]); // Reset line dash for other drawings

            // Draw paddles
            pongCtx.fillStyle = paddle1.color;
            pongCtx.fillRect(paddle1.x, paddle1.y, paddle1.width, paddle1.height);
            pongCtx.fillStyle = paddle2.color;
            pongCtx.fillRect(paddle2.x, paddle2.y, paddle2.width, paddle2.height);

            // Draw ball
            pongCtx.beginPath();
            pongCtx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            pongCtx.fillStyle = ball.color;
            pongCtx.fill();
        }

        function updatePong() {
            // Update paddle positions based on their velocity
            paddle1.y += paddle1.dy;
            paddle2.y += paddle2.dy;

            // Keep paddles within canvas bounds
            if (paddle1.y < 0) paddle1.y = 0;
            if (paddle1.y + paddle1.height > pongCanvas.height) paddle1.y = pongCanvas.height - paddle1.height;
            if (paddle2.y < 0) paddle2.y = 0;
            if (paddle2.y + paddle2.height > pongCanvas.height) paddle2.y = pongCanvas.height - paddle2.height;

            // Update ball position
            ball.x += ball.dx;
            ball.y += ball.dy;

            // Bounce ball off top/bottom walls
            if (ball.y - ball.radius < 0 || ball.y + ball.radius > pongCanvas.height) {
                ball.dy = -ball.dy;
            }

            // Ball collision with paddles
            // Paddle 1 (left)
            if (ball.dx < 0 && // Moving left
                ball.x - ball.radius < paddle1.x + paddle1.width && // Colliding with paddle's right edge
                ball.y > paddle1.y && // Ball is within paddle's vertical range
                ball.y < paddle1.y + paddle1.height) {
                ball.dx = -ball.dx; // Reverse horizontal direction
                // Adjust vertical bounce based on where it hit the paddle
                let collidePoint = ball.y - (paddle1.y + paddle1.height / 2);
                collidePoint = collidePoint / (paddle1.height / 2); // Normalize value between -1 and 1
                ball.dy = collidePoint * 5; // Adjust vertical speed
            }
            // Paddle 2 (right)
            else if (ball.dx > 0 && // Moving right
                     ball.x + ball.radius > paddle2.x && // Colliding with paddle's left edge
                     ball.y > paddle2.y && // Ball is within paddle's vertical range
                     ball.y < paddle2.y + paddle2.height) {
                ball.dx = -ball.dx; // Reverse horizontal direction
                // Adjust vertical bounce based on where it hit the paddle
                let collidePoint = ball.y - (paddle2.y + paddle2.height / 2);
                collidePoint = collidePoint / (paddle2.height / 2); // Normalize value
                ball.dy = collidePoint * 5; // Adjust vertical speed
            }

            // Check for scoring (ball goes past paddles)
            if (ball.x - ball.radius < 0) { // Player 2 scores
                player2Score++;
                updatePongScore();
                if (player2Score >= 5) {
                    gameOverPong("SPILLER 2 VANT! 🏆");
                } else {
                    serveBall(); // Serve new ball
                }
            } else if (ball.x + ball.radius > pongCanvas.width) { // Player 1 scores
                player1Score++;
                updatePongScore();
                if (player1Score >= 5) {
                    gameOverPong("SPILLER 1 VANT! 🏆");
                } else {
                    serveBall(); // Serve new ball
                }
            }
        }

        function updatePongScore() {
            pongScoreElement.textContent = `POENG: SPILLER 1: ${player1Score} - SPILLER 2: ${player2Score}`;
        }

        function gameOverPong(message) {
            if (pongAnimationFrameId) {
                cancelAnimationFrame(pongAnimationFrameId); // Stop game loop
                pongAnimationFrameId = null;
            }
            pongMessageElement.textContent = message; // Display game over/win message
        }

        function pongGameLoop() {
            updatePong(); // Update game state
            drawPong(); // Draw elements
            pongAnimationFrameId = requestAnimationFrame(pongGameLoop); // Loop recursively
        }

        function startGamePong() {
            if (pongAnimationFrameId) {
                return; // Prevent multiple game loops from running
            }
            pongMessageElement.textContent = ""; // Clear any previous messages
            serveBall(); // Start the ball
            pongGameLoop(); // Begin the game loop
        }

        function handlePongKeyPress(event) {
            keysPressed[event.key] = true; // Mark key as pressed
            if (pongAnimationFrameId === null) return; // Only process if game is running

            // Player 1 controls (W/S)
            if (keysPressed['w'] || keysPressed['W']) {
                paddle1.dy = -5; // Move up
            } else if (keysPressed['s'] || keysPressed['S']) {
                paddle1.dy = 5; // Move down
            }

            // Player 2 controls (ArrowUp/ArrowDown)
            if (keysPressed['ArrowUp']) {
                paddle2.dy = -5; // Move up
            } else if (keysPressed['ArrowDown']) {
                paddle2.dy = 5; // Move down
            }
        }

        function handlePongKeyRelease(event) {
            keysPressed[event.key] = false; // Mark key as released

            // Stop paddle movement if relevant key is released
            // For paddle1
            if (!(keysPressed['w'] || keysPressed['W'] || keysPressed['s'] || keysPressed['S'])) {
                paddle1.dy = 0;
            } else if (keysPressed['w'] || keysPressed['W']) { // If 'w' is still pressed after 's' is released
                paddle1.dy = -5;
            } else if (keysPressed['s'] || keysPressed['S']) { // If 's' is still pressed after 'w' is released
                paddle1.dy = 5;
            }

            // For paddle2
            if (!(keysPressed['ArrowUp'] || keysPressed['ArrowDown'])) {
                paddle2.dy = 0;
            } else if (keysPressed['ArrowUp']) { // If 'ArrowUp' is still pressed after 'ArrowDown' is released
                paddle2.dy = -5;
            } else if (keysPressed['ArrowDown']) { // If 'ArrowDown' is still pressed after 'ArrowUp' is released
                paddle2.dy = 5;
            }
        }

        // --- AI Chat (Removed from this visual layout to match image) ---
        // Functions and variables are kept but not called by the UI.
        let chatHistory = [];
        const AI_CHAT_HISTORY_KEY = 'aiChatHistory';
        const tools = []; // Tools will not be used in this simplified UI

        function displayAIChatMessage(message, type) { /* No-op in this UI */ }
        function loadAIChatHistory() { /* No-op in this UI */ }
        function saveAIChatHistory() { /* No-op in this UI */ }
        function resetAIChat() { /* No-op in this UI */ }
        async function sendMessage() { /* No-op in this UI */ return Promise.resolve(); } // Return a promise
        async function googleSearch(queries) { /* No-op in this UI */ return []; }

        // --- Bruker Chat (Firestore) ---
        let nicknameCache = {}; // Cache for nicknames to reduce Firestore reads

        async function getNickname(userId) {
            if (nicknameCache[userId]) {
                return nicknameCache[userId];
            }
            try {
                const nicknameDocRef = doc(db, `artifacts/${appId}/public/data/nicknames`, userId);
                const nicknameDocSnap = await getDoc(nicknameDocRef);
                if (nicknameDocSnap.exists()) {
                    const nickname = nicknameDocSnap.data().nickname;
                    nicknameCache[userId] = nickname; // Store in cache
                    return nickname;
                }
            } catch (error) {
                console.error("Feil ved henting av kallenavn fra Firestore:", error);
            }
            return 'UKJENT'; // Fallback if nickname not found or error occurs
        }


        function displayUserChatMessage(message, userId, timestamp) {
            const userChatOutput = document.getElementById('userChatOutput');
            if (!userChatOutput) return;

            const messageDiv = document.createElement('div');
            
            let messageClass = 'user-chat-message';
            // Use the actual currentUserId from the global window scope
            if (userId === window.auth.currentUser?.uid) { // Compare with authenticated user's UID
                messageClass = 'current-user-chat-message';
            }

            const date = timestamp ? new Date(timestamp.seconds * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) : 'NÅ';
            
            // Get nickname asynchronously and then append message
            getNickname(userId).then(nick => {
                messageDiv.className = `chat-message ${messageClass}`;
                messageDiv.innerHTML = `<span class="font-bold text-xs">${nick.toUpperCase()}</span> <span class="text-xs text-gray-200">${date}</span><br>${message.toUpperCase()}`;
                userChatOutput.appendChild(messageDiv);
                userChatOutput.scrollTop = userChatOutput.scrollHeight;
            }).catch(error => {
                console.error("Error fetching nickname for message:", error);
                // Fallback display if nickname fetching fails
                messageDiv.className = `chat-message ${messageClass}`;
                messageDiv.innerHTML = `<span class="font-bold text-xs">FEIL BRUKER</span> <span class="text-xs text-gray-200">${date}</span><br>${message.toUpperCase()}`;
                userChatOutput.appendChild(messageDiv);
                userChatOutput.scrollTop = userChatOutput.scrollHeight;
            });
        }

        function setupUserChatListener() {
            // Check if db and appId are available from the module script
            if (!window.db || !window.__app_id) {
                console.error("Firebase DB or App ID not available for chat listener.");
                document.getElementById('userChatOutput').innerHTML = '<div class="chat-message user-chat-message text-red-400">FEIL: KAN IKKE KOBLE TIL CHAT.</div>';
                return;
            }

            // Check if current user is authenticated before setting up listener
            if (!window.auth.currentUser) {
                console.warn("Firebase Auth not ready for User Chat listener. Waiting for authentication.");
                document.getElementById('userChatOutput').innerHTML = '<div class="chat-message user-chat-message" style="color: #FFFF00;">VENTER PÅ AUTENTISERING FOR CHAT...</div>';
                // Also clear previous messages
                document.getElementById('userChatOutput').innerHTML = '';
                return;
            }

            // Unsubscribe existing listener if any to avoid multiple listeners
            if (unsubscribeUserChat) {
                unsubscribeUserChat();
                unsubscribeUserChat = null;
                console.log("Existing chat listener unsubscribed.");
            }
             document.getElementById('userChatOutput').innerHTML = '<div class="chat-message user-chat-message" style="color: #FFFF00;">Laster chat-historikk...</div>';


            const chatCollectionRef = window.collection(window.db, `artifacts/${window.__app_id}/public/data/user_chats`);
            // orderBy is commented out as per instructions to avoid potential index issues unless explicitly needed and indexed
            const q = window.query(chatCollectionRef /*, window.orderBy('timestamp', 'asc')*/); 

            unsubscribeUserChat = window.onSnapshot(q, (snapshot) => {
                const userChatOutput = document.getElementById('userChatOutput');
                userChatOutput.innerHTML = ''; // Clear to reload all messages on snapshot change
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    displayUserChatMessage(data.message, data.userId, data.timestamp);
                });
            }, (error) => {
                console.error("Feil ved henting av chatmeldinger:", error);
                document.getElementById('userChatOutput').innerHTML = '<div class="chat-message user-chat-message text-red-400">FEIL VED LASTING AV CHATMELDINGER.</div>';
            });
            console.log("User chat listener subscribed.");
        }


        async function sendMessageUserChat() {
            const userChatInput = document.getElementById('userChatInput');
            const userChatSendButton = document.getElementById('userChatSendButton');
            const userChatLoadingIndicator = document.getElementById('userChatLoadingIndicator');
            const message = userChatInput.value.trim();

            if (message === '') {
                console.warn("Melding er tom.");
                return;
            }
            if (!window.auth.currentUser) {
                console.warn("Bruker er ikke autentisert. Kan ikke sende melding.");
                // Show a message to the user that they need to log in
                const chatOutput = document.getElementById('userChatOutput');
                if (chatOutput) {
                    const msgDiv = document.createElement('div');
                    msgDiv.className = `chat-message user-chat-message`;
                    msgDiv.style.color = '#FF00FF'; // Magenta for error
                    msgDiv.innerHTML = `FEIL: DU MÅ VÆRE LOGGET INN FOR Å SENDE MELDINGER.`;
                    chatOutput.appendChild(msgDiv);
                    chatOutput.scrollTop = chatOutput.scrollHeight;
                }
                return;
            }

            userChatInput.value = '';
            userChatSendButton.disabled = true;
            userChatLoadingIndicator.classList.remove('hidden');

            try {
                const chatCollectionRef = window.collection(window.db, `artifacts/${window.__app_id}/public/data/user_chats`);
                await window.addDoc(chatCollectionRef, {
                    userId: window.auth.currentUser.uid, // Use authenticated user's UID
                    message: message,
                    timestamp: window.serverTimestamp()
                });
            } catch (error) {
                console.error("Feil ved sending av melding:", error);
                const chatOutput = document.getElementById('userChatOutput');
                if (chatOutput) {
                    const msgDiv = document.createElement('div');
                    msgDiv.className = `chat-message user-chat-message`;
                    msgDiv.style.color = '#FF00FF'; // Magenta for error
                    msgDiv.innerHTML = `FEIL VED SENDING AV MELDING: ${error.message.toUpperCase()}`;
                    chatOutput.appendChild(msgDiv);
                    chatOutput.scrollTop = chatOutput.scrollHeight;
                }
            } finally {
                userChatSendButton.disabled = false;
                userChatLoadingIndicator.classList.add('hidden');
                userChatInput.focus();
            }
        }

        async function clearUserChat() {
            // Using a simple message box instead of confirm()
            const confirmClear = document.createElement('div');
            confirmClear.className = "fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50";
            confirmClear.innerHTML = `
                <div class="retro-box p-8 max-w-sm mx-auto text-center">
                    <p class="mb-4">ER DU SIKKER PÅ AT DU VIL TØMME HELE CHAT-HISTORIKKEN FOR ALLE BRUKERE? DENNE HANDLINGEN KAN IKKE ANGRERES.</p>
                    <button id="confirmClearBtn" class="retro-button mr-2">JA</button>
                    <button id="cancelClearBtn" class="retro-button">AVBRYT</button>
                </div>
            `;
            document.body.appendChild(confirmClear);

            return new Promise(resolve => {
                document.getElementById('confirmClearBtn').onclick = async () => {
                    document.body.removeChild(confirmClear);
                    const userChatOutput = document.getElementById('userChatOutput');
                    if (userChatOutput) {
                        userChatOutput.innerHTML = '<div class="chat-message user-chat-message" style="color: #FFFF00;">TØMMER CHAT...</div>'; // Feedback til bruker
                    }
                    try {
                        // Check if user is authenticated before allowing delete
                        if (!window.auth.currentUser) {
                            throw new Error("Du må være logget inn for å tømme chatten.");
                        }
                        // Only allow admin (or specific user) to clear if rules are set this way
                        // For simplicity, current rules allow any authenticated user to write to public_data/user_chats
                        // but a more robust app would have specific admin roles for clearing all
                        const chatCollectionRef = window.collection(window.db, `artifacts/${window.__app_id}/public/data/user_chats`);
                        const q = window.query(chatCollectionRef);
                        const querySnapshot = await window.getDocs(q);

                        const deletePromises = [];
                        querySnapshot.forEach((doc) => {
                            deletePromises.push(window.deleteDoc(window.doc(window.db, `artifacts/${window.__app_id}/public/data/user_chats`, doc.id)));
                        });
                        await Promise.all(deletePromises);
                        console.log("Chat historikk tømt.");
                        resolve(true); // Indicate success
                    } catch (error) {
                        console.error("Feil ved tømming av chat-historikk:", error);
                        if (userChatOutput) {
                            userChatOutput.innerHTML = `<div class="chat-message user-chat-message text-red-400">FEIL VED TØMMING AV CHAT: ${error.message.toUpperCase()}</div>`;
                        }
                        resolve(false); // Indicate failure
                    }
                };
                document.getElementById('cancelClearBtn').onclick = () => {
                    document.body.removeChild(confirmClear);
                    resolve(false); // Indicate cancellation
                };
            });
        }


        // Laster "Gjett Tallet"-spillet automatisk når siden lastes som standard
        window.onload = () => {
            // Initialiserer spillområdet, auth modal, og landing page for å kontrollere visning
            document.getElementById('landingPage').classList.remove('hidden'); // Show landing page initially
            document.getElementById('authModal').classList.add('hidden'); // Hide auth modal
            gameArea.classList.add('hidden'); // Hide game area
            topBox.classList.add('hidden'); // Hide top box
            userChatContainer.classList.add('hidden'); // Hide chat container
            footer.classList.add('hidden'); // Hide footer
        };

    </script>
</body>
</html>
